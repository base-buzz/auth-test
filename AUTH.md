# Authentication System Documentation (AUTH.md)\n\n## 1. Overview\n\nThis document explains the authentication system implemented in this project. It uses a **Sign-In with Ethereum (SIWE)** flow, managed by **NextAuth.js**, allowing users to log in using their Ethereum wallet.\n\n**Core Technologies:**\n\n* **NextAuth.js:** Handles session management, callbacks, and provider integration.\n* **SIWE:** Standard protocol for Ethereum wallet-based authentication.\n* **Wagmi & RainbowKit:** Used on the frontend for wallet connection and interaction.\n* **CredentialsProvider (NextAuth.js):** Custom provider to handle the SIWE verification logic.\n* **JWT Session Strategy:** NextAuth.js uses JSON Web Tokens for session management.\n\n## 2. Key Files\n\nUnderstanding the auth flow requires looking at these primary files:\n\n* `src/app/page.tsx`: Frontend component handling the user interaction for sign-in/sign-out.\n* `src/app/api/auth/[...nextauth]/route.ts`: Core NextAuth.js configuration (provider, callbacks, session strategy).\n* `src/lib/supabase.ts`: Initializes the client for the backend data source (used by NextAuth callbacks).\n* `src/types/next-auth.d.ts`: TypeScript definitions extending NextAuth types for custom session data.\n* `src/app/providers.tsx`: Wraps the application with necessary providers (`SessionProvider`, `WagmiProvider`, `RainbowKitProvider`).\n* `src/app/[handle]/page.tsx`: Example of a user-specific page, demonstrates accessing session data and conditional rendering.\n* `src/app/profile/page.tsx`: Example of a protected page requiring authentication.\n* `src/app/api/profile/route.ts`: Example of a protected API route.\n\n## 3. Authentication Flow (SIWE)\n\nThe sign-in process follows these steps:\n\n1. **Connect Wallet:** User connects their Ethereum wallet using the RainbowKit `ConnectButton` (`src/app/page.tsx`).\n2. **Initiate Sign-In:** User clicks the \"Sign In With Ethereum\" button (`handleSignIn` in `src/app/page.tsx`).\n3. **Fetch CSRF Token:** The client requests a CSRF token from NextAuth.js (`getCsrfToken`). This token is used as the `nonce` for the SIWE message to prevent replay attacks.\n4. **Create SIWE Message:** A SIWE message object (`SiweMessage`) is constructed including the user\'s address, domain, statement, URI, chain ID, and the fetched CSRF token as the `nonce`.\n5. **Sign Message:** The user is prompted via their wallet (using Wagmi\'s `useSignMessage`) to sign the prepared SIWE message.\n6. **Call NextAuth.js `signIn`:** The client calls `signIn(\'credentials\', ...)` passing the original SIWE message (as a JSON string) and the signature obtained in the previous step.\n7. **Backend Verification (`authorize`):**\n * The request hits the NextAuth.js backend (`src/app/api/auth/[...nextauth]/route.ts`).\n _ The `authorize` function within the `CredentialsProvider` is executed.\n _ It reconstructs the `SiweMessage` from the provided message string.\n * It fetches the *server-side* CSRF token/nonce again to ensure it matches.\n * It calls `siwe.verify({ signature, nonce })` to validate the signature against the message and the server-side nonce.\n _ **If verification succeeds:** It fetches/generates the user\'s unique `handle` from the data source (using the `getUserHandle` helper) and returns a `User` object containing `{ id: address, address: address, handle: handle }`.\n _ **If verification fails:** It returns `null`, denying authentication.\n8. **JWT Callback (`jwt`):**\n _ If `authorize` returned a `User` object (success), the `jwt` callback runs.\n _ On initial sign-in, it receives the `user` object from `authorize`.\n _ It adds the `handle` from the `user` object to the JWT `token`.\n _ On subsequent requests (session checks), it ensures the `handle` is still present in the token (refetching if necessary, though this shouldn\'t typically happen with JWT strategy).\n9. **Session Callback (`session`):**\n _ This callback runs after the `jwt` callback whenever a session is accessed on the client.\n _ It reads the `address` (from `token.sub`) and `handle` from the JWT `token`.\n _ It adds these custom properties (`address`, `handle`) to the `session.user` object.\n10. **Client Session Update:** The `useSession` hook on the client (`src/app/page.tsx`) detects the updated session status (`authenticated`) and the presence of `session.user.handle`.\n11. **Redirect:** The `useEffect` hook in `src/app/page.tsx` triggers a redirect using `router.push(\`/${session.user.handle}\`)`.\n\n## 4. Session Management\n\n_ **Strategy:** Uses JWT (`strategy: \"jwt\"`). Session state is stored in a secure, HTTP-only cookie containing the JWT.\n* **Client-Side Access:** Use the `useSession` hook from `next-auth/react` in Client Components. It provides:\n * `data`: The session object (e.g., `session.user.address`, `session.user.handle`) or `null`.\n _ `status`: \"authenticated\", \"unauthenticated\", or \"loading\".\n_ **Server-Side Access:** Use helpers like `getToken` from `next-auth/jwt` (preferred for API routes/Server Components) or potentially `getServerSession` from `next-auth` (requires `authOptions`).\n* **Custom Data:** The `jwt` and `session` callbacks are essential for adding custom data (`address`, `handle`) beyond the default user fields. The `src/types/next-auth.d.ts` file ensures TypeScript recognizes these custom fields.\n\n## 5. Protecting Routes\n\n### 5.1. Protecting Client Pages (Client Components)\n\nUse the `useSession` hook:\n\n`tsx\n\"use client\";\nimport { useSession } from \"next-auth/react\";\nimport { useRouter } from \"next/navigation\";\nimport { useEffect } from \"react\";\n\nexport default function ProtectedPage() {\n  const { data: session, status } = useSession();\n  const router = useRouter();\n\n  useEffect(() => {\n    if (status === \"unauthenticated\") {\n      router.push(\"/\"); // Redirect to login or home\n    }\n  }, [status, router]);\n\n  if (status === \"loading\") {\n    return <p>Loading...</p>;\n  }\n\n  if (status === \"unauthenticated\") {\n    // This might briefly show before redirect effect runs\n    return <p>Access Denied. Redirecting...</p>;\n  }\n\n  // Render content only for authenticated users\n  return (\n    <div>\n      <h1>Protected Content</h1>\n      <p>Welcome, {session?.user?.handle || session?.user?.address}!</p>\n    </div>\n  );\n}\n`\n*(See `src/app/profile/page.tsx` for an example)_\n\n### 5.2. Protecting API Routes / Server Components\n\nUse `getToken` from `next-auth/jwt`:\n\n`` typescript\nimport { getToken } from \"next-auth/jwt\";\nimport { type NextRequest, NextResponse } from \"next/server\";\n\nconst secret = process.env.NEXTAUTH_SECRET;\n\nexport async function GET(request: NextRequest) {\n  const token = await getToken({ req: request, secret });\n\n  if (!token || !token.sub) {\n    // No valid session token or missing user ID (address)\n    return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n  }\n\n  const userAddress = token.sub; // The user\'s address\n  const userHandle = token.handle; // Custom data from JWT\n\n  // Proceed with logic requiring authentication...\n  // const data = await fetchDataForUser(userAddress);\n\n  return NextResponse.json({ message: `Data for ${userHandle}` });\n}\n ``\n_(See `src/app/api/profile/route.ts` for an example)_\n\n## 6. `[handle]` Route and User Profiles\n\nThe dynamic route `src/app/[handle]/page.tsx` serves as the public profile page for users.\n\n_ It extracts the `handle` from the URL.\n* It fetches public user data using the unauthenticated API endpoint `GET /api/users/[handle]`.\n* It displays the fetched data.\n* It uses `useSession` to check if the *currently logged-in* user\'s handle matches the handle in the URL (`isOwnProfile`). If it matches, it displays a \"Welcome\" message and an \"Edit Profile\" button, linking to the protected `/profile` page.\n\n## 7. Vercel Deployment Considerations\n\n* **Environment Variables:** The following are critical for deployment on Vercel:\n _ `NEXTAUTH_URL`: The **canonical, public URL** of your deployment (e.g., `https://your-app.vercel.app`). This **must** match exactly what the user\'s browser sees in the address bar, as it\'s used in the SIWE message `domain` and `uri` fields for verification.\n _ `NEXTAUTH_SECRET`: A strong, unique secret used to sign session cookies/JWTs.\n _ `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`: For backend data source access.\n _ `SUPABASE_IMAGE_HOSTNAME`: If using `next/image` with Supabase Storage.\n* Set these variables in the Vercel project settings.\n\n## 8. **CRITICAL CODE SECTIONS - DO NOT MODIFY LIGHTLY**\n\nModifying the following sections without fully understanding the SIWE and NextAuth.js flow can easily break authentication:\n\n1. **`src/app/api/auth/[...nextauth]/route.ts` - `authorize` function:**\n * **WARNING:** This function performs the core SIWE signature verification. Changes to `siwe.verify`, CSRF token (`nonce`) handling, or the structure of the returned `User` object will break login.\n `typescript\n    // Inside CredentialsProvider\n    async authorize(credentials, req) { \n        // ... CRITICAL SIWE VERIFICATION LOGIC ...\n        const result = await siwe.verify({ signature, nonce: csrfToken });\n        if (result.success) {\n            // ... MUST return object matching augmented User type ...\n            return { id: ..., address: ..., handle: ... } as User;\n        }\n        return null;\n    }\n    `\n\n2. **`src/app/api/auth/[...nextauth]/route.ts` - `jwt` callback:**\n _ **WARNING:** This callback is responsible for adding the essential `handle` to the JWT. If this fails or is removed, the `handle` will not be available in the session, breaking redirects and profile links.\n `typescript\n    async jwt({ token, user, ... }) { \n        // ... logic to add token.handle ...\n        return token;\n    }\n    `\n\n3. **`src/app/api/auth/[...nextauth]/route.ts` - `session` callback:**\n _ **WARNING:** This callback makes the `address` and `handle` available to the client via `useSession`. Removing fields here will make them unavailable on the frontend.\n `typescript\n    async session({ session, token }) {\n        session.user.address = token.sub;\n        session.user.handle = token.handle;\n        return session;\n    }\n    `\n\n4. **`src/types/next-auth.d.ts`:**\n _ **WARNING:** This type declaration file **must** accurately reflect the custom properties added to the `User`, `JWT`, and `Session` objects in the NextAuth.js callbacks. Mismatches will cause TypeScript errors or runtime issues.\n\n5. **`src/app/page.tsx` - `handleSignIn` function:**\n _ **WARNING:** The process of getting the CSRF token, creating the SIWE message (especially setting the correct `nonce`), signing, and calling `signIn` must be maintained correctly.\n\n**General Rule:** Before modifying any files listed in Section 2, carefully review the existing logic and understand its role in the authentication flow described in Section 3.\n\n## 9. Extending / Maintaining\n\n* **Adding Protected Routes:** Follow the patterns described in Section 5.\n* **Adding Data to Session:** If more user data is needed in the session:\n 1. Modify `getUserHandle` (or create a similar helper) to fetch the additional data.\n 2. Update the `authorize` return object _if_ the data is needed immediately for the `User` type.\n 3. Update the `jwt` callback to add the new data to the `token`.\n 4. Update the `session` callback to copy the new data from the `token` to the `session.user` object.\n 5. Update `src/types/next-auth.d.ts` to include the new types in the `User`, `JWT`, and `Session` interfaces.\n\* **Backend Interactions:** Ensure server-side interactions with the data source (e.g., in API routes or callbacks) use the `supabaseAdmin` client and properly handle authentication/authorization based on the user's address retrieved via `getToken` or session callbacks.\n\nThis documentation should provide a clear guide for maintaining and extending the authentication system.
